import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';

class Task {
  final String objectId;
  final String title;
  final String description;
  final String dueDate;
  bool completed;

  Task({
    required this.objectId,
    required this.title,
    required this.description,
    required this.dueDate,
    required this.completed,
  });

  factory Task.fromJson(Map<String, dynamic> json) {
    return Task(
      objectId: json['objectId'],
      title: json['title'] ?? 'No Title',
      description: json['description'] ?? 'No Description',
      dueDate: json['due_date'] ?? 'No Due Date',
      completed: json['completed'] == '1',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'title': title,
      'description': description,
      'due_date': dueDate,
      'completed': completed,
    };
  }
}

class TaskService {
  static const String baseUrl = 'http://127.0.0.1:8000';

  static Future<List<Task>> fetchTasks() async {
    final response = await http.get(Uri.parse('$baseUrl/get_tasks'));
    if (response.statusCode == 200) {
      List<dynamic> jsonTasks = jsonDecode(response.body);
      return jsonTasks.map((json) => Task.fromJson(json)).toList();
    } else {
      throw Exception('Failed to fetch tasks');
    }
  }

  static Future<void> addTask(Task task) async {
    final response = await http.post(
      Uri.parse('$baseUrl/create_task'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode(task.toJson()),
    );
    if (response.statusCode != 200) {
      throw Exception('Failed to add task');
    }
  }

  static Future<void> updateTask(Task task) async {
    final response = await http.put(
      Uri.parse('$baseUrl/update_task/${task.objectId}'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode(task.toJson()),
    );
    if (response.statusCode != 200) {
      throw Exception('Failed to update task');
    }
  }

  static Future<void> deleteTask(String taskId) async {
    final response = await http.delete(
      Uri.parse('$baseUrl/delete_task/$taskId'),
    );
    if (response.statusCode != 204) {
      throw Exception('Failed to delete task');
    }
  }
}

class TaskManagementScreen extends StatefulWidget {
  @override
  _TaskManagementScreenState createState() => _TaskManagementScreenState();
}

class _TaskManagementScreenState extends State<TaskManagementScreen> {
  List<Task> tasks = [];
  bool isLoading = false;

  @override
  void initState() {
    super.initState();
    _fetchTasks();
  }

  Future<void> _fetchTasks() async {
    setState(() {
      isLoading = true;
    });
    try {
      List<Task> fetchedTasks = await TaskService.fetchTasks();
      setState(() {
        tasks = fetchedTasks;
        isLoading = false;
      });
    } catch (e) {
      print('Error fetching tasks: $e');
      setState(() {
        isLoading = false;
      });
      // Show error message to the user
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to fetch tasks')),
      );
    }
  }

  Future<void> _addTask() async {
    // Show dialog for adding a task
    TextEditingController titleController = TextEditingController();
    TextEditingController descriptionController = TextEditingController();
    TextEditingController dueDateController = TextEditingController();

    await showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('Add Task'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: titleController,
                decoration: InputDecoration(labelText: 'Title'),
              ),
              TextField(
                controller: descriptionController,
                decoration: InputDecoration(labelText: 'Description'),
              ),
              TextField(
                controller: dueDateController,
                decoration: InputDecoration(labelText: 'Due Date'),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: Text('Cancel'),
            ),
            TextButton(
              onPressed: () async {
                Task newTask = Task(
                  objectId: '', // Empty ID as it will be generated by the server
                  title: titleController.text,
                  description: descriptionController.text,
                  dueDate: dueDateController.text,
                  completed: false, // New tasks are not completed by default
                );
                await TaskService.addTask(newTask);
                _fetchTasks(); // Refresh task list after adding task
                Navigator.of(context).pop(); // Close dialog
              },
              child: Text('Add'),
            ),
          ],
        );
      },
    );
  }

  Future<void> _toggleTaskCompletion(Task task) async {
    task.completed = !task.completed;
    try {
      await TaskService.updateTask(task);
      _fetchTasks(); // Refresh task list after updating task
    } catch (e) {
      print('Error toggling task completion: $e');
      // Show error message to the user
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to toggle task completion')),
      );
    }
  }

  Future<void> _editTask(Task task) async {
    // Show dialog for editing a task
    TextEditingController titleController =
        TextEditingController(text: task.title);
    TextEditingController descriptionController =
        TextEditingController(text: task.description);
    TextEditingController dueDateController =
        TextEditingController(text: task.dueDate);

    await showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('Edit Task'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: titleController,
                decoration: InputDecoration(labelText: 'Title'),
              ),
              TextField(
                controller: descriptionController,
                decoration: InputDecoration(labelText: 'Description'),
              ),
              TextField(
                controller: dueDateController,
                decoration: InputDecoration(labelText: 'Due Date'),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: Text('Cancel'),
            ),
            TextButton(
              onPressed: () async {
                Task editedTask = Task(
                  objectId: task.objectId,
                  title: titleController.text,
                  description: descriptionController.text,
                  dueDate: dueDateController.text,
                  completed: task.completed,
                );
                await TaskService.updateTask(editedTask);
                _fetchTasks(); // Refresh task list after updating task
                Navigator.of(context).pop(); // Close dialog
              },
              child: Text('Save'),
            ),
          ],
        );
      },
    );
  }

  Future<void> _deleteTask(Task task) async {
    // Show confirmation dialog before deleting the task
    bool confirmDelete = await showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('Confirm Delete'),
          content: Text('Are you sure you want to delete this task?'),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop(false); // Cancel delete
              },
              child: Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                Navigator.of(context).pop(true); // Confirm delete
              },
              child: Text('Delete'),
            ),
          ],
        );
      },
    );

    if (confirmDelete == true) {
      try {
        await TaskService.deleteTask(task.objectId);
        _fetchTasks(); // Refresh task list after deleting task
      } catch (e) {
        print('Error deleting task: $e');
        // Show error message to the user
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to delete task')),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Task Management'),
      ),
      body: isLoading
          ? Center(
              child: CircularProgressIndicator(),
            )
          : tasks.isEmpty
              ? Center(
                  child: Text('No tasks found'),
                )
              : ListView.builder(
                  itemCount: tasks.length,
                  itemBuilder: (context, index) {
                    return Card(
                      child: ListTile(
                        title: Text(tasks[index].title),
                        subtitle: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text('Description: ${tasks[index].description}'),
                            Text('Due Date: ${tasks[index].dueDate}'),
                          ],
                        ),
                        trailing: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            IconButton(
                              icon: Icon(Icons.edit),
                              onPressed: () => _editTask(tasks[index]),
                            ),
                            IconButton(
                              icon: Icon(Icons.delete),
                              onPressed: () => _deleteTask(tasks[index]),
                            ),
                            Checkbox(
                              value: tasks[index].completed,
                              onChanged: (_) =>
                                  _toggleTaskCompletion(tasks[index]),
                            ),
                          ],
                        ),
                        onTap: () {
                          // Add logic to navigate to task details screen
                          // Pass the task object to the details screen
                        },
                      ),
                    );
                  },
                ),
      floatingActionButton: FloatingActionButton(
        onPressed: _addTask,
        child: Icon(Icons.add),
      ),
    );
  }
}

void main() {
  runApp(MaterialApp(
    home: TaskManagementScreen(),
  ));
}
